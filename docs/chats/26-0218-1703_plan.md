# План: Чат 1 — Backend skeleton (FastAPI, БД, auth, RAG CRUD)

**Дата:** 2026-02-18, 17:03  
**Цель:** Создать работающий backend `ferag`: структура проекта, схема БД, аутентификация JWT, CRUD пользователей и RAG-экземпляров (включая создание датасетов в Fuseki), эндпоинт статуса задач. Проверка через Swagger UI.  
**Объём:** Работа, выполнимая в пределах одного чата.  
**Предшественник:** [26-0215-1600_plan.md](26-0215-1600_plan.md) (вариант A RAG реализован; резюме: [26-0215-1600_plan_resume.md](26-0215-1600_plan_resume.md)).

---

## Исходное состояние

- RAG-диалог работает как CLI-скрипт (`graphrag-test/rag_chat.py`); нет веб-интерфейса.
- Архитектура веб-приложения согласована и задокументирована: [PROJECT-004.md](../project/PROJECT-004.md).
- Операционные конфиги (`deploy/`) готовы; реализация кода не начата.
- PostgreSQL доступен локально на `localhost:45432` (nb-win, Docker).
- Fuseki доступен локально на `localhost:43030` (nb-win, Docker).
- Папки `code/backend/`, `code/worker/`, `code/frontend/` не существуют (исходный код приложения — в `code/`).

**Окружение для разработки (этот чат):** локально в WSL2 на nb-win, `uvicorn` из виртуального окружения `code/backend/venv`. PostgreSQL и Fuseki — те же локальные экземпляры. Docker, cr-ubu — для Чата 3.

---

## Задача плана

Реализовать **backend skeleton**: структура `code/backend/`, зависимости, схема БД с Alembic, аутентификация (register/login/JWT), CRUD RAG-экземпляров (создание датасета в Fuseki при создании RAG), эндпоинт polling-статуса задач. По завершении: `uvicorn` запущен, Swagger UI доступен, сценарий «register → login → create RAG → list RAGs» работает, датасет в Fuseki создаётся.

---

## Соглашения (зафиксировать в начале чата)

### Структура каталогов

Исходный код приложения — в `code/`. Backend:

```
code/backend/
├── requirements.txt
├── .env.example
├── alembic.ini
├── alembic/
│   ├── env.py
│   └── versions/
│       └── 0001_initial.py      # создаётся в шаге 2
└── app/
    ├── __init__.py
    ├── main.py                  # FastAPI app, подключение роутеров
    ├── config.py                # pydantic-settings, .env
    ├── db.py                    # engine, SessionLocal, Base
    ├── models.py                # ORM-модели всех таблиц
    ├── auth.py                  # bcrypt + JWT утилиты
    ├── deps.py                  # get_db, get_current_user
    ├── fuseki_admin.py          # HTTP-клиент Fuseki admin API
    └── routers/
        ├── __init__.py
        ├── auth.py              # /auth/register, /auth/login, /auth/me
        ├── rags.py              # /rags CRUD
        └── tasks.py             # /tasks/{task_id}
```

### Схема БД

```sql
users (
    id            SERIAL PRIMARY KEY,
    email         TEXT UNIQUE NOT NULL,
    password_hash TEXT NOT NULL,
    display_name  TEXT,
    created_at    TIMESTAMPTZ DEFAULT now()
)

rag_instances (
    id              SERIAL PRIMARY KEY,
    owner_id        INTEGER REFERENCES users(id),
    name            TEXT NOT NULL,
    description     TEXT,
    fuseki_dataset  TEXT NOT NULL,   -- ferag-{id:05d}
    cycle_count     INTEGER DEFAULT 0,
    created_at      TIMESTAMPTZ DEFAULT now()
)

rag_members (
    rag_id   INTEGER REFERENCES rag_instances(id),
    user_id  INTEGER REFERENCES users(id),
    role     TEXT NOT NULL,    -- 'viewer' | 'editor'
    PRIMARY KEY (rag_id, user_id)
)

upload_cycles (
    id          SERIAL PRIMARY KEY,
    rag_id      INTEGER REFERENCES rag_instances(id),
    cycle_n     INTEGER NOT NULL,
    status      TEXT NOT NULL DEFAULT 'pending',
    --          pending | running | review | merged | archived | failed
    created_at  TIMESTAMPTZ DEFAULT now(),
    merged_at   TIMESTAMPTZ
)

tasks (
    id             SERIAL PRIMARY KEY,
    rag_id         INTEGER REFERENCES rag_instances(id),
    cycle_id       INTEGER REFERENCES upload_cycles(id),
    type           TEXT NOT NULL,
    --             graphrag | schema_induction | merge_ontologies |
    --             merge_triples | load_to_prod
    status         TEXT NOT NULL DEFAULT 'pending',
    --             pending | running | done | failed
    celery_task_id TEXT,
    error          TEXT,
    created_at     TIMESTAMPTZ DEFAULT now(),
    updated_at     TIMESTAMPTZ DEFAULT now()
)
```

### Именование датасетов Fuseki

```python
def rag_prod_dataset(rag_id: int) -> str:
    return f"ferag-{rag_id:05d}"

def rag_staging_dataset(rag_id: int, cycle_n: int) -> str:
    return f"ferag-{rag_id:05d}-new-{cycle_n:05d}"

def rag_triples_dataset(rag_id: int, cycle_n: int) -> str:
    return f"ferag-{rag_id:05d}-new-{cycle_n:05d}-triples"

def rag_ontology_dataset(rag_id: int, cycle_n: int) -> str:
    return f"ferag-{rag_id:05d}-new-{cycle_n:05d}-ontology"
```

### Зависимости (`requirements.txt`)

```
fastapi
uvicorn[standard]
sqlalchemy
alembic
psycopg2-binary
passlib[bcrypt]
python-jose[cryptography]
pydantic-settings
python-dotenv
httpx
python-multipart
```

### `.env.example`

```
DATABASE_URL=postgresql://ferag:ferag2026@localhost:45432/ferag_app
JWT_SECRET=change-me-generate-with-openssl-rand-hex-32
JWT_ALGORITHM=HS256
JWT_EXPIRE_MINUTES=60
FUSEKI_URL=http://localhost:43030
FUSEKI_USER=admin
FUSEKI_PASSWORD=ferag2026
```

---

## Шаги

### ✅ 1. Структура проекта и конфигурация

#### ✅ 1.1 Создать `code/backend/` и виртуальное окружение

Создать каталог `code/backend/`, виртуальное окружение, установить зависимости из `requirements.txt`. Создать `.env` из `.env.example` и заполнить реальными значениями для локальной разработки.

Проверка: `python -c "import fastapi, sqlalchemy, passlib, jose"` без ошибок.

**Исполнение:** созданы `code/backend/`, `requirements.txt`, `.env.example`; venv в `code/backend/venv`, зависимости установлены; `.env` заполнен (DATABASE_URL, FUSEKI_* — localhost; JWT_SECRET сгенерирован через `openssl rand -hex 32`). Проверка импортов пройдена.

#### ✅ 1.2 `config.py` — настройки приложения

Реализовать `Settings` на базе `pydantic_settings.BaseSettings`: поля `database_url`, `jwt_secret`, `jwt_algorithm`, `jwt_expire_minutes`, `fuseki_url`, `fuseki_user`, `fuseki_password`. Синглтон `get_settings()` через `@lru_cache`.

**Исполнение:** в `app/config.py` добавлены класс `Settings` (BaseSettings, загрузка из `.env`), поля по плану, значения по умолчанию для `jwt_algorithm` и `jwt_expire_minutes`; `get_settings()` с `@lru_cache`. Проверка: при запуске из `code/backend` настройки читаются из `.env`.

#### ✅ 1.3 `db.py` — SQLAlchemy engine и сессия

`create_engine(settings.database_url)`, `SessionLocal = sessionmaker(...)`, `Base = declarative_base()`. Функция `get_db()` — FastAPI dependency (yield + close).

**Исполнение:** в `app/db.py` добавлены `engine` (из `get_settings().database_url`), `SessionLocal`, `Base` (declarative_base()), генератор `get_db()` с yield сессии и закрытием в `finally`. Проверка: импорт и вызов `get_db()` проходят; подключение к реальной БД проверено — при запущенном PostgreSQL (ferag-postgres на localhost:45432) выполнение `db.execute(text('SELECT 1'))` через `get_db()` возвращает результат.

#### ✅ 1.4 `app/main.py` — FastAPI app

`app = FastAPI(title="ferag API", root_path="/ferag/api")`. Пока без роутеров — только `GET /health` → `{"status": "ok"}`. Запуск из `code/backend/`: `uvicorn app.main:app --reload --port 47821`.

Проверка: `curl http://localhost:47821/health` → `{"status": "ok"}`. `http://localhost:47821/docs` открывается.

**Исполнение:** в `app/main.py` созданы приложение FastAPI с `title="ferag API"`, `root_path="/ferag/api"` и эндпоинт `GET /health` → `{"status": "ok"}`. Проверка: запуск `uvicorn app.main:app --port 47821` из `code/backend/`, `curl http://localhost:47821/health` возвращает `{"status":"ok"}`.

---

### 2. Схема БД и миграции

#### 2.1 `models.py` — ORM-модели

Реализовать модели для всех пяти таблиц из соглашений: `User`, `RagInstance`, `RagMember`, `UploadCycle`, `Task`. `__tablename__` — snake_case. Все внешние ключи с `ForeignKey`, индексы на `email`, `owner_id`.

#### 2.2 Alembic: инициализация и первая миграция

```bash
alembic init alembic
# Настроить alembic/env.py:
#   target_metadata = Base.metadata
#   sqlalchemy.url из config (через get_settings())
alembic revision --autogenerate -m "initial"
alembic upgrade head
```

Проверка: `psql` → `\dt` — видны все 5 таблиц. Повторный `alembic upgrade head` не выдаёт ошибок.

---

### 3. Аутентификация (JWT + bcrypt)

#### 3.1 `auth.py` — утилиты

Функции: `hash_password(plain: str) -> str` (passlib bcrypt), `verify_password(plain, hashed) -> bool`, `create_access_token(data: dict) -> str` (python-jose, exp = now + `jwt_expire_minutes`), `decode_access_token(token: str) -> dict` (decode + проверка exp).

#### 3.2 `deps.py` — зависимости

`get_db()` (уже в `db.py`, импортировать). `get_current_user(token: str = Depends(oauth2_scheme), db = Depends(get_db)) -> User`: decode token → получить `user_id` → `db.get(User, user_id)` → 401 если не найден.

#### 3.3 `routers/auth.py` — эндпоинты

- `POST /auth/register` — тело: `{email, password, display_name?}`. Проверить уникальность email (409 если занят), создать `User`, вернуть `{id, email, display_name}`.
- `POST /auth/login` — тело: `{email, password}` (form или JSON). Найти пользователя, `verify_password`, создать токен, вернуть `{access_token, token_type: "bearer"}`.
- `GET /auth/me` — `Depends(get_current_user)`, вернуть текущего пользователя.

Подключить роутер в `main.py`: `app.include_router(auth_router, prefix="/auth", tags=["auth"])`.

Проверка через Swagger UI: register → login → скопировать токен → нажать «Authorize» → GET /auth/me возвращает данные пользователя.

---

### 4. Fuseki admin клиент

#### 4.1 `fuseki_admin.py`

Класс или набор функций с `httpx.Client`, basic auth (`fuseki_user`:`fuseki_password`):

- `create_dataset(name: str, db_type="tdb2")` — `POST {fuseki_url}/$/datasets` с form-полями `dbName={name}&dbType={db_type}`. Идемпотентно: если датасет уже существует (409 от Fuseki) — не считать ошибкой.
- `delete_dataset(name: str)` — `DELETE {fuseki_url}/$/datasets/{name}`.
- `list_datasets() -> list[str]` — `GET {fuseki_url}/$/datasets`, вернуть список имён.

Проверка: вызвать `create_dataset("ferag-test")` → датасет виден в `http://localhost:43030` → вызвать `delete_dataset("ferag-test")` → исчез.

---

### 5. RAG CRUD

#### 5.1 `routers/rags.py` — эндпоинты

- `POST /rags` — тело: `{name, description?}`. Текущий пользователь = владелец. Создать запись `RagInstance` (пока без `fuseki_dataset`), `db.flush()` чтобы получить `id`, задать `fuseki_dataset = rag_prod_dataset(rag.id)`, `db.commit()`. Вызвать `fuseki_admin.create_dataset(rag.fuseki_dataset)`. Вернуть созданный RAG.
- `GET /rags` — список RAG текущего пользователя: `owner_id == user.id` OR в `rag_members`. Вернуть список.
- `GET /rags/{rag_id}` — проверить доступ (owner или member), вернуть RAG.
- `DELETE /rags/{rag_id}` — только owner. Проверить, нет ли запущенных задач. Удалить запись. `fuseki_admin.delete_dataset(rag.fuseki_dataset)` — попытаться удалить prod-датасет (не падать при ошибке).

Подключить: `app.include_router(rags_router, prefix="/rags", tags=["rags"])`.

Проверка: создать RAG через Swagger → вернулся объект с `fuseki_dataset = "ferag-00001"` → открыть `http://localhost:43030` → датасет `ferag-00001` виден в списке.

#### 5.2 Вспомогательные функции датасетов

Добавить в `fuseki_admin.py` (или отдельный `rag_datasets.py`) четыре функции из соглашений: `rag_prod_dataset`, `rag_staging_dataset`, `rag_triples_dataset`, `rag_ontology_dataset`.

---

### 6. Эндпоинт статуса задач

#### 6.1 `routers/tasks.py`

- `GET /tasks/{task_id}` — проверить доступ пользователя к RAG, к которому относится задача, вернуть `{id, rag_id, cycle_id, type, status, error, created_at, updated_at}`.
- `GET /rags/{rag_id}/tasks` — список всех задач для RAG (пагинация: `?skip=0&limit=20`).

Задачи в Чате 1 могут быть пустыми (Worker ещё не реализован); эндпоинты нужны для polling из Чата 2.

Подключить: `app.include_router(tasks_router, tags=["tasks"])`.

---

### 7. Финальная проверка

Полный сценарий через Swagger UI (`http://localhost:47821/docs`):

1. `POST /auth/register` → новый пользователь.
2. `POST /auth/login` → access token. Нажать «Authorize», вставить токен.
3. `POST /rags` с `{name: "Тестовый RAG"}` → `{id: 1, fuseki_dataset: "ferag-00001", ...}`.
4. `GET /rags` → список с одним RAG.
5. Открыть `http://localhost:43030` → датасет `ferag-00001` присутствует.
6. `DELETE /rags/1` → 204. Датасет в Fuseki исчез.
7. `GET /rags` → пустой список.

---

## Контур следующих чатов

### Чат 2 — Worker + полный цикл обновления RAG

**Исходное:** backend skeleton готов; задачи записываются в БД; Worker не реализован.

**Задача:** Реализовать `code/worker/` (Celery-приложение). Расширить backend: эндпоинт загрузки файла и WebSocket статусов. Обеспечить полный цикл: загрузка текста → GraphRAG → RDF → Fuseki (-triples) → Schema Induction → Fuseki (-ontology) → слияние онтологий → слияние триплетов → Fuseki (-new) → уведомление пользователя → подтверждение → мерж в prod-датасет.

**Ключевые шаги:**
- `code/worker/` структура, `celery_app.py`, брокер Redis `redis://10.7.0.1:47379/0`.
- Переиспользование `graphrag-test/` как библиотеки (добавить в `sys.path` или сделать `graphrag_lib` пакетом).
- Celery task chain: `run_graphrag` → `run_schema_induction` → `merge_ontologies` → `merge_triples` → `load_to_staging`.
- Backend: `POST /rags/{rag_id}/upload` — принять файл, создать `UploadCycle`, запустить chain.
- Backend WebSocket: `WS /ws/tasks/{task_id}` — live-статус (pub/sub через Redis).
- Backend: `POST /rags/{rag_id}/cycles/{cycle_id}/approve` — мерж staging в prod-датасет, `DELETE` промежуточных.

**Проверка:** curl upload файла → статус через WebSocket → RAG-вопрос к новому датасету возвращает ответ.

---

### Чат 3 — Frontend (Vue) + деплой

**Исходное:** backend + worker полностью работают; frontend отсутствует; всё запущено локально.

**Задача:** Реализовать `code/frontend/` (Vue 3 + Vite). Собрать и задеплоить на cr-ubu. Запустить всё через Docker.

**Ключевые шаги:**
- `code/frontend/` структура, Vite `base: '/ferag/'`, роутер, pinia, axios.
- Страницы: Login/Register, список RAG, детальная карточка RAG, загрузка файла + прогресс, диалог (вопрос/ответ), управление участниками.
- `npm run build` → dist/; rsync/scp на cr-ubu в `/var/www/ferag/`.
- `code/backend/Dockerfile` — python:3.11-slim + redis-server + supervisor (из `supervisord.conf`).
- `docker-compose up -d` на cr-ubu и nb-win; Nginx — подключить `nginx-location-ferag.conf`.
- `POST /rags/{rag_id}/members` — API приглашений (опционально перенести из Чата 2).

**Проверка:** `https://ontoline.ru/ferag/` в браузере: register → create RAG → upload → вопрос → ответ LLM.

---

## Критерии успеха (Чат 1)

- `uvicorn app.main:app` запускается без ошибок; `GET /health` → 200.
- Swagger UI доступен на `http://localhost:47821/docs`.
- Сценарий «register → login → authorize → create RAG → list RAGs» полностью работает.
- После `POST /rags` датасет `ferag-{id:05d}` виден в Fuseki Admin UI.
- Все 5 таблиц созданы в PostgreSQL через `alembic upgrade head`.

---

## Вне объёма данного плана (перенесено в следующие чаты)

- Загрузка файлов и запуск Celery-задач (Чат 2).
- WebSocket (Чат 2).
- Управление участниками RAG, эндпоинты приглашений (Чат 2/3).
- Диалоговый чат (вопрос → LLM-ответ) через API (Чат 2).
- Vue frontend (Чат 3).
- Docker, деплой на cr-ubu (Чат 3).

---

## Ссылки

- Архитектура веб-приложения: [docs/project/PROJECT-004.md](../project/PROJECT-004.md)
- Задачи: [docs/tasks/TASKS.md](../tasks/TASKS.md) (Блок 9, задачи 9.1–9.2)
- Операционные конфиги: [deploy/](../../deploy/)
- Предшествующий план (RAG, вариант A): [26-0215-1600_plan.md](26-0215-1600_plan.md)
